# 基本函数

> **来源**: https://www.myquant.cn/docs2/sdk/python/API介绍/基本函数.html
> **标题**: 基本函数 - 掘金量化

---

# # 基本函数

## # init - 初始化策略

初始化策略, 策略启动时自动执行。可以在这里初始化策略配置参数。

**函数原型：**
    
    
    init(context)**参数：**

参数名 | 类型 | 说明  
---|---|---  
context | [context](/docs2/sdk/python/变量约定.html#context-上下文对象) | 上下文，全局变量可存储在这里  
  
**示例：**
    
    
    def init(context):
        # 订阅bar
        subscribe(symbols='SHSE.600000,SHSE.600004', frequency='30s', count=5)
    	# 增加对象属性，如:设置一个股票资金占用百分比
    	context.percentage_stock = 0.8**注意：**

**1.** 回测模式下init函数里不支持交易操作，仿真模式和实盘模式支持。

**2.** init只会在策略启动时运行一次，如果不是每天重启策略，每天需要查询更新数据，可以通过设置定时任务执行。

## # schedule - 定时任务配置

在指定时间自动执行策略算法, 通常用于选股类型策略

**函数原型：**
    
    
    schedule(schedule_func, date_rule, time_rule)**参数：**

参数名 | 类型 | 说明  
---|---|---  
schedule_func | function | 策略定时执行算法  
date_rule | str | n + 时间单位， 可选'd/w/m' 表示 n 天/n 周/n 月  
time_rule | str | 执行算法的具体时间 (%H:%M:%S 格式)  
  
**返回值：**

`None`

**示例：**
    
    
    def init(context):
        #每天的19:06:20执行策略algo_1
        schedule(schedule_func=algo_1, date_rule='1d', time_rule='19:06:20')
    	#每月的第一个交易日的09:40:00执行策略algo_2
    	schedule(schedule_func=algo_2, date_rule='1m', time_rule='9:40:00')
    
    def algo_1(context):
        print(context.symbols)
    
    def algo_2(context):
        order_volume(symbol='SHSE.600000', volume=200, side=OrderSide_Buy, order_type=OrderType_Market, position_effect=PositionEffect_Open)**注意：**

**1.** time_rule 的时,分,秒均不可以只输入个位数，例:`'9:40:0'`或`'14:5:0'`

**2.** 目前暂时支持`1d`、`1w`、`1m`，其中`1w`、`1m`仅用于回测

## # run - 运行策略

**函数原型：**
    
    
    run(strategy_id='', filename='', mode=MODE_UNKNOWN, token='', backtest_start_time='',
        backtest_end_time='', backtest_initial_cash=1000000,
        backtest_transaction_ratio=1, backtest_commission_ratio=0,
        backtest_slippage_ratio=0, backtest_adjust=ADJUST_NONE, backtest_check_cache=1,
        serv_addr='', backtest_match_mode=0, backtest_intraday=0)**参数：**

参数名 | 类型 | 说明  
---|---|---  
strategy_id | str | 策略 id  
filename | str | 策略文件名称  
mode | int | 策略模式 MODE_LIVE(实时)=1 MODE_BACKTEST(回测) =2  
token | str | 用户标识  
backtest_start_time | str | 回测开始时间 (%Y-%m-%d %H:%M:%S 格式)  
backtest_end_time | str | 回测结束时间 (%Y-%m-%d %H:%M:%S 格式)  
backtest_initial_cash | double | 回测初始资金, 默认 1000000  
backtest_transaction_ratio | double | 回测成交比例, 默认 1.0, 即下单 100%成交  
backtest_commission_ratio | double | 回测佣金比例, 默认 0  
backtest_slippage_ratio | double | 回测滑点比例, 默认 0  
backtest_adjust | int | 回测复权方式(默认不复权) ADJUST_NONE(不复权)=0 ADJUST_PREV(前复权)=1 ADJUST_POST(后复权)=2  
backtest_check_cache | int | 回测是否使用缓存：1 - 使用， 0 - 不使用；默认使用  
serv_addr | str | 终端服务地址, 默认本地地址, 可不填，若需指定应输入 ip+端口号，如"127.0.0.1:7001"  
backtest_match_mode | int | 回测市价撮合模式： 1-实时撮合：在当前 bar 的收盘价/当前 tick 的 price 撮合，0-延时撮合：在下个 bar 的开盘价/下个 tick 的 price 撮合，默认是模式 0  
backtest_intraday | int | 回测模式不订阅行情，current 和 current_price 行情数据查询函数返回的日线价格类型：  
1 - 当日收盘价: 回测当前交易日的日线收盘价（T日盘中和盘后均为T日收盘价）;   
0 - 历史收盘价：回测当前时刻的历史最新日线收盘价（T日盘中为T-1日收盘价，T日盘后为T日收盘价），默认是0  
  
**返回值：**

`None`

**示例：**
    
    
    run(strategy_id='strategy_1', filename='main.py', mode=MODE_BACKTEST, token='token_id',
        backtest_start_time='2016-06-17 13:00:00', backtest_end_time='2017-08-21 15:00:00')**注意：**

**1.** run 函数中，`mode=1`也可改为`mode=MODE_LIVE`，两者等价，`backtest_adjust`同理

**2.** 在前复权和后复权回测模式下，是不会处理分红、送股、拆分事件的，因为除权除息产生的变动已经通过复权因子调整反映在前复权/后复权股价中，无需重复处理。不复权会自动处理分红送转。

**3.** filename 指运行的 py 文件名字，如该策略文件名为 Strategy.py,则此处应填"Strategy.py"

## # stop - 停止策略

停止策略，退出策略进程

**函数原型：**
    
    
    stop()**返回值：**

`None`

**示例：**
    
    
    #若订阅过的代码集合为空，停止策略
    if not context.symbols:
       stop()## # timer - 设置定时器

设定定时器的间隔秒数，每过设定好的秒数调用一次计时器 timer_func()，直到 timer_stop()结束定时器为止。 （仿真、实盘场景适用，回测模式下不生效）

**函数原型：**
    
    
    timer(timer_func, period, start_delay)**参数：**

参数名 | 类型 | 说明  
---|---|---  
timer_func | function | 在 timer 设置的时间到达时触发的事件函数  
period | int | 定时事件间隔毫秒数，设定每隔多少毫秒触发一次定时器，范围在 [1,43200000]  
start_delay | int | 等待秒数(毫秒)，设定多少毫秒后启动定时器，范围在[0,43200000]  
  
**返回值： dict**

字段 | 类型 | 说明  
---|---|---  
timer_status | int | 定时器设置是否成功，成功=0，失败=非 0 错误码（timer_id 无效）。  
timer_id | int | 设定好的定时器 id  
  
## # `timer_stop` \- 停止定时器

停止已设置的定时器

**函数原型：**
    
    
    timer_stop(timer_id)**参数：**

字段 | 类型 | 说明  
---|---|---  
timer_id | int | 要停止的定时器 id  
  
**返回值：**

字段 | 类型 | 说明  
---|---|---  
is_stop | bool | 是否成功停止，True or False  
  
**示例：**
    
    
    def init(context):
        # 每隔1分钟执行ontime_1, 即时启动
        context.timerid_1 = timer(timer_func=ontimer_1, period=60000, start_delay=0)
        context.counter_1 = 0
    
        # 每隔半小时执行ontime_2, 5分钟之后启动
        context.timerid_2 = timer(timer_func=ontimer_2, period=300000, start_delay=0)
        print('启动定时器2：', context.now)
        context.counter_2 = 0
    
    
    def ontimer_1(context):
        # 定时器执行次数计数
        context.counter_1 += 1
        # 定时器执行逻辑
        print('定时器1：', context.now)
    
    
    def ontimer_2(context):
        # 定时器执行次数计数
        context.counter_2 += 1
        # 定时器执行逻辑（如查询账户资金）
        cash = context.account().cash
    
        print('定时器2：', context.now)
    
        # 按执行次数条件停止定时器
        if context.counter_1 >= 5:
            ret1 = timer_stop(context.timerid_1['timer_id'])
            if ret1:
                print("结束1分钟定时器")
    
        if context.counter_2 >= 10:
            ret2 = timer_stop(context.timerid_2['timer_id'])**注意：**

**1.** 仿真、实盘场景适用，回测模式下不生效

**2.** period 从前一次事件函数开始执行时点起算，若下一次事件函数需要执行时，前一次事件函数没运行完毕，等待上一个事件执行完毕再执行下一个事件。

* * *

上次更新: 8/5/2025, 4:38:13 PM

← [ 数据结构 ](/docs2/sdk/python/数据结构.html) [ 数据订阅 ](/docs2/sdk/python/API介绍/数据订阅.html) → 

